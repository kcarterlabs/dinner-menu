from flask import Flask, request, jsonify
from flask_cors import CORS
import json
import os
import shutil
from datetime import datetime
import requests
import time
import random
import logging
from logging.handlers import RotatingFileHandler

app = Flask(__name__)
CORS(app)  # Enable CORS for frontend access

# Configuration
RECIPES_FILE = "recipes.json"
BACKUP_DIR = "backups"

# Logging configuration
if not os.path.exists('logs'):
    try:
        os.makedirs('logs')
    except (OSError, PermissionError):
        pass

try:
    file_handler = RotatingFileHandler('logs/api.log', maxBytes=10240000, backupCount=10)
    file_handler.setFormatter(logging.Formatter(
        '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'
    ))
    file_handler.setLevel(logging.INFO)
    app.logger.addHandler(file_handler)
    app.logger.setLevel(logging.INFO)
    app.logger.info('Dinner Menu API startup')
except (OSError, PermissionError):
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    app.logger.addHandler(console_handler)
    app.logger.setLevel(logging.INFO)

# Initialize MongoDB (with fallback if not available)
try:
    from db import RecipeDB, convert_objectid_to_str
    recipe_db = RecipeDB()
    app.logger.info('MongoDB initialized successfully')
    USE_MONGODB = True
except Exception as e:
    app.logger.warning(f'MongoDB not available, using JSON fallback: {e}')
    recipe_db = None
    USE_MONGODB = False

# ============= Recipe Management Functions =============

def load_recipes():
    """Load recipes from MongoDB or JSON file."""
    if USE_MONGODB and recipe_db:
        try:
            recipes = recipe_db.get_all_recipes()
            return convert_objectid_to_str(recipes)
        except Exception as e:
            app.logger.error(f"MongoDB error: {e}, falling back to JSON")
    
    # Fallback to JSON
    if os.path.exists(RECIPES_FILE):
        with open(RECIPES_FILE, "r") as f:
            try:
                return json.load(f)
            except json.JSONDecodeError:
                return []
    return []

def save_recipes(data):
    """Save recipes to JSON, with a backup of the old file."""
    if os.path.exists(RECIPES_FILE):
        os.makedirs(BACKUP_DIR, exist_ok=True)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_file = os.path.join(BACKUP_DIR, f"recipes_{timestamp}.json")
        shutil.copy(RECIPES_FILE, backup_file)

    with open(RECIPES_FILE, "w") as f:
        json.dump(data, f, indent=4)

# ============= Weather & Dinner Menu Functions =============

def get_weather_forecast(days):
    """Fetch weather forecast for specified days."""
    api_key = os.getenv('RAPID_API_FORECAST_KEY')
    
    if not api_key:
        raise ValueError("RAPID_API_FORECAST_KEY environment variable not set")
    
    url = "https://weatherapi-com.p.rapidapi.com/forecast.json"
    querystring = {"q": "Spokane", "days": days}
    headers = {
        "x-rapidapi-key": api_key,
        "x-rapidapi-host": "weatherapi-com.p.rapidapi.com"
    }
    
    response = requests.get(url, headers=headers, params=querystring)
    response.raise_for_status()
    data = response.json()
    
    city = data["location"]["name"]
    region = data["location"]["region"]
    
    formatted = [
        {
            "day": datetime.strptime(day['date'], '%Y-%m-%d').strftime('%A'),
            "date": day['date'],
            "temp": day['day']['maxtemp_f']
        }
        for day in data["forecast"]["forecastday"]
    ]
    
    return {
        "location": f"{city}, {region}",
        "forecast": formatted
    }

def generate_grocery_list(recipes):
    """Generate a consolidated grocery list from selected recipes."""
    if USE_MONGODB and recipe_db:
        try:
            recipe_ids = [r.get('_id') for r in recipes if '_id' in r]
            if recipe_ids:
                return recipe_db.aggregate_ingredients(recipe_ids)
        except Exception as e:
            app.logger.warning(f"MongoDB aggregation failed: {e}")
    
    # Fallback: simple ingredient counting
    all_ingredients = []
    for recipe in recipes:
        ingredients_list = recipe.get('ingredients', [])
        for ingredient in ingredients_list:
            if isinstance(ingredient, dict):
                ingredient_str = ingredient.get('original', str(ingredient))
            else:
                ingredient_str = str(ingredient)
            all_ingredients.append(ingredient_str)
    
    ingredient_counts = {}
    for ingredient in all_ingredients:
        ingredient_lower = ingredient.lower().strip()
        ingredient_counts[ingredient_lower] = ingredient_counts.get(ingredient_lower, 0) + 1
    
    return sorted([
        {"ingredient": ing, "count": count}
        for ing, count in ingredient_counts.items()
    ], key=lambda x: x['ingredient'])

def select_dinner_recipes(weather_data, days, reroll_index=None, current_menu=None):
    """Select recipes based on weather and days needed."""
    temps = [day['temp'] for day in weather_data['forecast']]
    too_hot = any(temp > 90 for temp in temps)
    
    recipes = load_recipes()
    
    # Handle re-roll
    if reroll_index is not None and current_menu:
        selected_recipes = current_menu.copy()
        available_recipes = [
            r for r in recipes 
            if not (too_hot and r.get("oven", False)) 
            and r not in current_menu
        ]
        random.shuffle(available_recipes)
        if available_recipes and 0 <= reroll_index < len(selected_recipes):
            selected_recipes[reroll_index] = available_recipes[0]
        total_portions = sum(int(r.get("portions", "1")) for r in selected_recipes)
    else:
        # Initial generation
        available_recipes = [r for r in recipes if not (too_hot and r.get("oven", False))]
        random.shuffle(available_recipes)
        selected_recipes = []
        total_portions = 0
        for recipe in available_recipes:
            if total_portions >= days:
                break
            portions = int(recipe.get("portions", "1"))
            selected_recipes.append(recipe)
            total_portions += portions
    
    grocery_list = generate_grocery_list(selected_recipes)
    
    return {
        "selected_recipes": selected_recipes,
        "total_portions": total_portions,
        "days_requested": days,
        "too_hot_for_oven": too_hot,
        "grocery_list": grocery_lis
    return sorted([
        {"ingredient": ing, "count": count}
        for ing, count in ingredient_counts.items()
    ], key=lambda x: x['ingredient'])

def select_dinner_recipes(weather_data, days):
    """Select recipes based on weather and days needed."""
    temps = [day['temp'] for day in weather_data['forecast']]
    too_hot = any(temp > 90 for temp in temps)
    
    recipes = load_recipes()
    
    available_recipes = [r for r in recipes if not (too_hot and r.get("oven", False))]
    random.shuffle(available_recipes)
    
    selected_recipes = []
    total_portions = 0
    
    for recipe in available_recipes:
        portions = int(recipe.get("portions", "1"))
        selected_recipes.append(recipe)
        total_portions += portions
        
        if total_portions >= days:
            break
    
    return {
        "selected_recipes": selected_recipes,
        "total_portions": total_portions,
        "days_requested": days,
        "too_hot_for_oven": too_hot
    }

# ============= API Routes =============

@app.route('/api/health', methods=['GET'])
def health():
    """Health check endpoint."""
    return jsonify({"status": "healthy", "message": "Dinner Menu API is running"})

@app.route('/api/recipes', methods=['GET'])
def get_recipes():
    """Get all recipes."""
    recipes = load_recipes()
    return jsonify({
        "success": True,
        "count": len(recipes),
        "recipes": recipes
    })

@app.route('/api/recipes', methods=['POST'])
def add_recipe():
    """Add a new recipe."""
    try:
        data = request.get_json()
        
        # Validate required fields
        required_fields = ['title', 'ingredients']
        for field in required_fields:
            if field not in data:
                return jsonify({
                    "success": False,
                    "error": f"Missing required field: {field}"
                }), 400
        
        # Create recipe object
        recipe = {
            "title": data['title'],
            "date": data.get('date', datetime.now().strftime('%Y-%m-%d')),
            "ingredients": data['ingredients'] if isinstance(data['ingredients'], list) else [i.strip() for i in data['ingredients'].split(',')],
            "oven": data.get('oven', False),
            "stove": data.get('stove', False),
            "portions": data.get('portions', "1")
        }
        
        # Load, add, and save
        recipes = load_recipes()
        recipes.append(recipe)
        save_recipes(recipes)
        
        return jsonify({
            "success": True,
            "message": "Recipe added successfully",
            "recipe": recipe
        }), 201
        
    except Exception as e:
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/recipes/<int:index>', methods=['DELETE'])
def delete_recipe(index):
    """Delete a recipe by index."""
    try:
        recipes = load_recipes()
        
        if index < 0 or index >= len(recipes):
            return jsonify({
                "success": False,
                "error": "Recipe index out of range"
            }), 404
        
        deleted_recipe = recipes.pop(index)
        save_recipes(recipes)
        
        return jsonify({
            "success": True,
            "message": "Recipe deleted successfully",
            "deleted_recipe": deleted_recipe
        })
        
    except Exception as e:
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/weather', methods=['GET'])
def get_weather():
    """Get weather forecast."""
    try:
        days = request.args.get('days', default=7, type=int)
        
        if days < 1 or days > 14:
            return jsonify({
                "success": False,
                "error": "Days must be between 1 and 14"
            }), 400
        , 'POST'])
def get_dinner_menu():
    """Get dinner menu suggestions based on weather and days."""
    try:
        days = request.args.get('days', default=7, type=int)
        
        if days < 1 or days > 14:
            return jsonify({
                "success": False,
                "error": "Days must be between 1 and 14"
            }), 400
        
        # Check if POST (re-roll)
        if request.method == 'POST':
            data = request.get_json()
            weather_data = data.get('weather')
            reroll_index = data.get('reroll_index')
            current_menu = data.get('current_menu', [])
            
            if not weather_data:
                return jsonify({
                    "success": False,
                    "error": "Weather data required for re-roll"
                }), 400
        else:
            # GET: fetch fresh weather
            weather_data = get_weather_forecast(days)
            reroll_index = None
            current_menu = []
        
        # Select recipes
        dinner_plan = select_dinner_recipes(weather_data, days, reroll_index, current_menu""
    try:
        days = request.args.get('days', default=7, type=int)
        
        if days < 1 or days > 14:
            return jsonify({
                "success": False,
                "error": "Days must be between 1 and 14"
            }), 400
        
        # Get weather forecast
        weather_data = get_weather_forecast(days)
        
        # Select recipes
        dinner_plan = select_dinner_recipes(weather_data, days)
        
        return jsonify({
            "success": True,
            "weather": weather_data,
            "dinner_plan": dinner_plan
        })
        
    except Exception as e:
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/dinner-menu/quick', methods=['GET'])
def get_quick_dinner_menu():
    """Get dinner menu suggestions without weather (random selection)."""
    try:
        days = request.args.get('days', default=7, type=int)
        
        if days < 1 or days > 14:
            return jsonify({
                "success": False,
                "error": "Days must be between 1 and 14"
            }), 400
        
        recipes = load_recipes()
        random.shuffle(recipes)
        
        selected_recipes = []
        total_portions = 0
        
        for recipe in recipes:
            portions = int(recipe.get("portions", "1"))
            selected_recipes.append(recipe)
            total_portions += portions
            
            if total_portions >= days:
                break
        
        return jsonify({
            "success": True,
            "dinner_plan": {
                "selected_recipes": selected_recipes,
                "total_portions": total_portions,
                "days_requested": days
            }
        })
        
    except Exception as e:
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)
